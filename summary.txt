1. Why did I choose the tools, libraries, and language for the coding exercise?
I chose Python as the language for this project because I am very familiar with it. My familiarity allows me to write and debug code more efficiently, making the development process smoother. Python is also known for its simplicity and readability, which makes it a great choice for rapid prototyping. I can quickly test and iterate on my ideas, which is ideal for this type of coding exercise.
For the web framework, I chose Flask because it is lightweight and easy to set up. It requires minimal boilerplate code, which makes it perfect for small to medium-sized applications like this one. Flask offers flexibility in how I structure the application, as it doesn’t impose a rigid framework or dependencies. This gives me greater control over the application design, allowing me to tailor the project to my needs. Additionally, Flask has a strong community and extensive documentation, which is incredibly helpful when I encounter issues or need to implement specific features.

2. What are the advantages and disadvantages of my solution?
Advantages:
Memory Optimization: I used a deque to store transactions because it allows for efficient addition and removal of transactions from both ends. This is especially useful in the spend_points function, where I need to process transactions in the order they were added.
Performance: By using a defaultdict for tracking balances, I don’t need to check whether a key exists before updating it. This simplifies the code and improves performance.
Transaction Management: The solution ensures that transactions are inserted in the correct order based on their timestamp, which is crucial for accurately spending points in the order they were earned.

Disadvantages:
Data Retention: Once a transaction has been processed and removed, it's gone, which helps optimize memory usage. However, this could be a drawback if I ever need to audit or analyze past transactions, as historical data would be lost.
Scalability: While Flask is excellent for small to medium-sized applications, it might not be the best choice for highly scalable, large-scale systems. If the project grows, I might need to explore more robust frameworks or architectures.
Error Handling: My current implementation has basic error handling. For a production system, I would need to improve this by adding more comprehensive error handling and logging to ensure reliability and maintainability.

3. What has been a favorite school/personal project thus far? What about it that challenged you?
My favorite school project thusfar has been creating the system calls for an operating system from scratch. This is a pretty famous project (xk OS) out of MIT that is the basis of my Operating Systems class. I deeply enjoyed this project because it involved lots of design and had real consequences as well. If I managed to build a good design at the start, debugging and updating my OS with new operating calls would be easier, but if I had a bad design, I would struggle with many bugs later down the line. This project was extremely challenging as it operated on very low level systems, so debugging was incredibly hard as I would have to read through assembly instructions step by step and check many different details (memory spaces, null pointer exceptions, etc). Designing an OS was also challenging, as I had to understand each system call at a fundamental level to be able to support it without bugs. Overall, the project grew me a lot as a Software Engineer as I learned how to design big systems from the ground up and work through understanding my code piece by piece on the assembly level.
